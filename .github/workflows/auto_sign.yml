name: Auto-sign (Session-Based)

on:
  schedule:
    - cron: '0 21 * * *'
  workflow_dispatch:

jobs:
  auto-sign:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python 3.9
        uses: actions/setup-python@v4
        with:
          python-version: 3.9
      
      - name: Clone private repository (veiled-journeys)
        env:
          PAT: ${{ secrets.GITCODE_TOKEN }}
        run: |
          git clone https://Jyf0214:${PAT}@gitcode.com/Jyf0214/veiled-journeys.git
 
      - name: Cache pip dependencies
        # 注意: key 现在可以只依赖于 veiled-journeys/requirements.txt
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/veiled-journeys/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      
      # 步骤 5: 启动会话 (解密所有文件到硬盘)
      - name: Start Session (Decrypt All Files)
        working-directory: ./veiled-journeys
        env:
          Jyf0214_PASSWORD: ${{ secrets.Jyf0214_PASSWORD }}
        run: |
          pip install -r requirements.txt
          python main.py start
      
      # 步骤 6: 安装依赖并执行业务逻辑 (在解密后的目录中)
      - name: Install Dependencies & Run Business Logic
        # 现在所有操作都在解密后的 Jyf0214 目录中进行
        working-directory: ./veiled-journeys/Jyf0214
        env:
          # 所有 secrets 正常传递
          # Sushang WebDAV
          SUSHANG_WEBDAV_USERNAME: ${{ secrets.SUSHANG_WEBDAV_USERNAME }}
          SUSHANG_WEBDAV_PASSWORD: ${{ secrets.SUSHANG_WEBDAV_PASSWORD }}

          # GoFile API
          GOFILE_API_TOKEN: ${{ secrets.GOFILE_API_TOKEN }}

          # Jike TeraCloud WebDAV
          JIKE_WEBDAV_USERNAME: ${{ secrets.JIKE_WEBDAV_USERNAME }}
          JIKE_WEBDAV_PASSWORD: ${{ secrets.JIKE_WEBDAV_PASSWORD }}

          # Upstash Redis
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}

          # Yandex WebDAV
          YANDEX_WEBDAV_USERNAME: ${{ secrets.YANDEX_WEBDAV_USERNAME }}
          YANDEX_WEBDAV_PASSWORD: ${{ secrets.YANDEX_WEBDAV_PASSWORD }}

          # Koofr WebDAV
          # 注意：即使 Koofr 的 URL 不是秘密，但将其作为环境变量传入可以增加灵活性
          KOOFR_WEBDAV_BASE_URL: ${{ secrets.KOOFR_WEBDAV_BASE_URL }}
          KOOFR_WEBDAV_USERNAME: ${{ secrets.KOOFR_WEBDAV_USERNAME }}
          KOOFR_WEBDAV_PASSWORD: ${{ secrets.KOOFR_WEBDAV_PASSWORD }}
          GitHub_Actions: true
          TOTKEN: ${{ secrets.TOKEN }}
          SUBJECT: ${{ secrets.SUBJECT }}
          TO_EMAIL: ${{ secrets.TO_EMAIL }}
          Git_EMAIL: ${{ secrets.TO_EMAIL }}
          FROM_EMAIL: ${{ secrets.FROM_EMAIL }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          PHONE: ${{ secrets.PHONE }}
          PASSWORD: ${{ secrets.PASSWORD }}
        run: |
          # 先安装依赖
          pip install -r ../requirements.txt 
          
          # 然后像本地开发一样，直接运行 python 命令
          # 所有 import 和文件引用都会正常工作
          python skyland.py
          python smtp.py
          python bingapi.py
          python git.py
          python src/dailymessage.py
          python review_images.py

      # 步骤 7: 执行部署任务 (同样在解密后的目录中)
      - name: Prepare and Deploy Skland App
        working-directory: ./veiled-journeys/Jyf0214/Skland
        run: |
          echo "Checking for TOKEN.txt..."
          if [ ! -f "./TOKEN.txt" ]; then exit 1; fi

          echo "Packaging..."
          pip install --target=./ requests cryptography cffi
          find . -type d -name '*dist-info' -exec rm -rf {} +
          zip -r code.zip .
          
          # 直接运行解密后的 sync.py 来执行上传
          echo "Deploying..."
          python sync.py

      - name: Cleanup Session (Remove All Decrypted Files)
        # `if: always()` 确保此步骤总是运行
        if: always()
        working-directory: ./veiled-journeys
        run: |
          # 运行新 main.py 的 cleanup 命令
          python main.py cleanup