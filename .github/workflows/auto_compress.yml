name: Rclone-Unified Parallel Video Compression (Corrected & Final)

on:
  workflow_dispatch:

env:
  REMOTE_DIR: ${{ github.run_id }}
  WORKFLOW_RUN_ID: ${{ github.run_id }}

jobs:
  # 任务1：分割视频，解密脚本，并分别缓存产物
  split_and_cache:
    runs-on: ubuntu-latest
    outputs:
      matrix_payload: ${{ steps.split.outputs.matrix_array }}
      original_filename: ${{ steps.split.outputs.original_filename }}
    steps:
      - name: Install FFmpeg
        run: sudo apt-get update && sudo apt-get install -y ffmpeg

      - name: Clone veiled-journeys repository
        env:
          PAT: ${{ secrets.GITCODE_TOKEN }} 
        run: git clone https://Jyf0214:${PAT}@gitcode.com/Jyf0214/veiled-journeys.git

      - name: Install Python requirements
        working-directory: ./veiled-journeys
        run: pip install -r requirements.txt

      - name: Start Session (Decrypt veiled-journeys)
        working-directory: ./veiled-journeys
        env:
          Jyf0214_PASSWORD: ${{ secrets.Jyf0214_PASSWORD }}
        run: python main.py start

      - name: Download Original Video (Using Encrypted Script)
        run: |
          mkdir -p original_video
          python veiled-journeys/Jyf0214/webdav_download.py -a="MyVideos/" -b="./original_video/" -c=1

      - name: Split video, generate matrix, and get filename
        id: split
        run: |
          mkdir -p video_segments
          ORIGINAL_FILE=$(find ./original_video -maxdepth 1 -type f \( -name "*.mp4" -o -name "*.mkv" \) -print -quit)
          ORIGINAL_FILENAME=$(basename "$ORIGINAL_FILE")
          echo "original_filename=${ORIGINAL_FILENAME}" >> $GITHUB_OUTPUT
          ffmpeg -i "$ORIGINAL_FILE" -c copy -f segment -segment_time 60 -reset_timestamps 1 "video_segments/segment_%03d.mp4"
          COUNT=$(ls -1 video_segments/*.mp4 | wc -l)
          echo "count=$COUNT" >> $GITHUB_OUTPUT
          if [ "$COUNT" -gt 0 ]; then
            SEQUENCE=$(seq 0 $(($COUNT - 1)) | tr '\n' ',' | sed 's/,$//')
            JSON_ARRAY="[${SEQUENCE}]"
          else
            JSON_ARRAY="[]"
          fi
          echo "matrix_array=${JSON_ARRAY}" >> $GITHUB_OUTPUT

      - name: Save Original Video to Cache
        uses: actions/cache/save@v4
        with:
          path: original_video/
          key: original-${{ env.WORKFLOW_RUN_ID }}

      - name: Save Segments to Cache
        uses: actions/cache/save@v4
        with:
          path: video_segments/
          key: segments-${{ env.WORKFLOW_RUN_ID }}

      - name: Cleanup Session (Remove Decrypted Files)
        if: always()
        working-directory: ./veiled-journeys
        run: python main.py cleanup

  # 任务2：并行压缩和上传
  compress_and_upload_to_b2:
    runs-on: ubuntu-latest
    needs: split_and_cache
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        segment_index: ${{ fromJSON(needs.split_and_cache.outputs.matrix_payload) }}
    steps:
      - name: Install Dependencies (ffmpeg, rclone)
        run: |
          sudo apt-get update 
          sudo apt-get install -y ffmpeg
          sudo -v ; curl https://rclone.org/install.sh | sudo bash

      - name: Restore Uncompressed Segments from Cache
        uses: actions/cache/restore@v4
        with:
          path: video_segments/
          key: segments-${{ env.WORKFLOW_RUN_ID }}
          fail-on-cache-miss: true

      - name: Configure Rclone
        env:
          B2_KEY_ID: ${{ secrets.B2_KEY_ID }}
          B2_APPLICATION_KEY: ${{ secrets.B2_APPLICATION_KEY }}
        run: |
          mkdir -p ~/.config/rclone
          cat << EOF > ~/.config/rclone/rclone.conf
          [b2_remote]
          type = b2
          account = ${B2_KEY_ID}
          key = ${B2_APPLICATION_KEY}
          EOF
      
      - name: Process and Upload One Segment
        run: |
          mkdir -p compressed_output
          FORMATTED_INDEX=$(printf "%03d" ${{ matrix.segment_index }})
          INPUT_FILE="video_segments/segment_${FORMATTED_INDEX}.mp4"
          OUTPUT_FILE="compressed_output/compressed_${FORMATTED_INDEX}.mp4"
          ffmpeg -y -i "$INPUT_FILE" -c:v libx265 -preset veryslow -crf 18 -tag:v hvc1 -c:a copy "$OUTPUT_FILE"
          BASENAME=$(basename "$OUTPUT_FILE")
          rclone copyto "$OUTPUT_FILE" "b2_remote:${{ secrets.B2_BUCKET_NAME }}/${{ env.REMOTE_DIR }}/compressed/${BASENAME}"

  # 任务3：合并和上传
  merge_from_b2_and_upload:
    runs-on: ubuntu-latest
    needs: [split_and_cache, compress_and_upload_to_b2]
    steps:
      - name: Install Dependencies (ffmpeg, rclone)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg
          sudo -v ; curl https://rclone.org/install.sh | sudo bash

      - name: Restore Original Video from Cache
        uses: actions/cache/restore@v4
        with:
          path: original_video/
          key: original-${{ env.WORKFLOW_RUN_ID }}
          fail-on-cache-miss: true

      - name: Configure Rclone for B2
        env:
          B2_KEY_ID: ${{ secrets.B2_KEY_ID }}
          B2_APPLICATION_KEY: ${{ secrets.B2_APPLICATION_KEY }}
          B2_DOWNLOAD_URL: ${{ secrets.B2_DOWNLOAD_URL }}
        run: |
          mkdir -p ~/.config/rclone
          cat << EOF > ~/.config/rclone/rclone.conf
          [b2_remote]
          type = b2
          account = ${B2_KEY_ID}
          key = ${B2_APPLICATION_KEY}
          download_url = ${B2_DOWNLOAD_URL}
          EOF

      - name: Download all compressed segments from B2
        run: |
          mkdir -p compressed_segments
          rclone copy "b2_remote:${{ secrets.B2_BUCKET_NAME }}/${{ env.REMOTE_DIR }}/compressed" ./compressed_segments

      - name: Clone, Install, and Decrypt Scripts
        env:
          PAT: ${{ secrets.GITCODE_TOKEN }}
          Jyf0214_PASSWORD: ${{ secrets.Jyf0214_PASSWORD }}
        run: |
          git clone https://Jyf0214:${PAT}@gitcode.com/Jyf0214/veiled-journeys.git
          cd veiled-journeys
          pip install -r requirements.txt
          python main.py start
      
      - name: Merge, Compare and Select Final File
        id: merge_and_select
        env:
          ORIGINAL_FILENAME: ${{ needs.split_and_cache.outputs.original_filename }}
        run: |
          find ./compressed_segments -type f -name "*.mp4" | sort -V | while read -r f; do echo "file '$f'" >> file_list.txt; done
          if [ ! -s file_list.txt ]; then echo "::error::No compressed segments found to merge."; exit 1; fi
          # 已有正确的引号，无需修改
          ffmpeg -f concat -safe 0 -i file_list.txt -c copy "${ORIGINAL_FILENAME}"
          ORIGINAL_FILE=$(find ./original_video -maxdepth 1 -type f \( -name "*.mp4" -o -name "*.mkv" \) -print -quit)
          # 已有正确的引号，无需修改
          MERGED_FILE="${ORIGINAL_FILENAME}"
          ORIGINAL_SIZE=$(stat -c%s "$ORIGINAL_FILE")
          MERGED_SIZE=$(stat -c%s "$MERGED_FILE")
          FINAL_FILE_PATH="$ORIGINAL_FILE"
          if [ -f "$MERGED_FILE" ] && [ "$MERGED_SIZE" -lt "$ORIGINAL_SIZE" ] && [ "$MERGED_SIZE" -gt 0 ]; then
            FINAL_FILE_PATH="$MERGED_FILE"
          fi
          echo "final_file=${FINAL_FILE_PATH}" >> $GITHUB_OUTPUT

      # --- 修正点：对变量赋值使用双引号以处理带空格的文件名 ---
      - name: Upload to GoFile (Using Encrypted Script)
        run: |
          FINAL_FILE_TO_UPLOAD="${{ steps.merge_and_select.outputs.final_file }}"
          echo "Uploading ${FINAL_FILE_TO_UPLOAD}..."
          python veiled-journeys/Jyf0214/gofile_manager.py upload --file "$FINAL_FILE_TO_UPLOAD" --list-file "compressed_videos_list.txt"

      - name: Cleanup Session (Remove Decrypted Files)
        if: always()
        working-directory: ./veiled-journeys
        run: python main.py cleanup

  cleanup_github_cache:
    runs-on: ubuntu-latest
    needs: [merge_from_b2_and_upload] 
    if: always()                                    # 无论前面成功失败都执行
    steps:
      - name: Delete GitHub Actions cache entries
        uses: actions/github-script@v7
        with:
          script: |
            const keys = [
              `original-${process.env.WORKFLOW_RUN_ID}`,
              `segments-${process.env.WORKFLOW_RUN_ID}`
            ];
            for (const k of keys) {
              try {
                // 先列出该 key 对应的缓存 id
                const { data } = await github.rest.actions.getActionsCacheList({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  key: k
                });
                if (data.actions_caches.length === 0) {
                  console.log(`No cache found for key ${k}`);
                  continue;
                }
                // 逐个删除
                for (const c of data.actions_caches) {
                  await github.rest.actions.deleteActionsCacheById({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    cache_id: c.id
                  });
                  console.log(`Deleted cache id ${c.id} (key ${k})`);
                }
              } catch (e) {
                console.warn(`Failed to delete cache key ${k}:`, e.message);
              }
            }

      - name: Install Rclone
        run: sudo -v ; curl https://rclone.org/install.sh | sudo bash
      - name: Configure Rclone
        env:
          B2_KEY_ID: ${{ secrets.B2_KEY_ID }}
          B2_APPLICATION_KEY: ${{ secrets.B2_APPLICATION_KEY }}
        run: |
          mkdir -p ~/.config/rclone
          cat << EOF > ~/.config/rclone/rclone.conf
          [b2_remote]
          type = b2
          account = ${B2_KEY_ID}
          key = ${B2_APPLICATION_KEY}
          EOF
      - name: Purge temporary directory from B2 with Rclone
        run: |
          echo "Purging remote directory: ${{ env.REMOTE_DIR }}"
          rclone purge "b2_remote:${{ secrets.B2_BUCKET_NAME }}/${{ env.REMOTE_DIR }}"