name: Video Compression Workflow - Segmented & RAM Disk Optimized

on:
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      # 缓存和依赖安装步骤保持不变
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache Dependencies
        id: cache-deps
        uses: actions/cache@v4
        with:
          path: |
            /var/cache/apt/archives
            /var/lib/apt/lists
            ~/.cache/pip
            /usr/local/bin/ffmpeg
            /usr/local/bin/ffprobe
          key: ${{ runner.os }}-deps-ffmpeg-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-deps-ffmpeg-

      - name: Setup Dependencies
        run: |
          if [ ! -f /usr/local/bin/ffmpeg ]; then
            echo "FFmpeg/FFprobe not found in cache, installing..."
            sudo apt-get update
            sudo apt-get install -y ffmpeg
            sudo cp /usr/bin/ffmpeg /usr/local/bin/ffmpeg
            sudo cp /usr/bin/ffprobe /usr/local/bin/ffprobe
          else
            echo "FFmpeg/FFprobe found in cache."
            sudo ln -s /usr/local/bin/ffmpeg /usr/bin/ffmpeg || true
            sudo ln -s /usr/local/bin/ffprobe /usr/bin/ffprobe || true
          fi

      - name: Create RAM Disk
        run: |
          sudo mkdir /mnt/ramdisk
          sudo mount -t tmpfs -o size=4G tmpfs /mnt/ramdisk
          df -h

      # 克隆、安装、下载等步骤全部指向 RAM Disk
      - name: Clone veiled-journeys repository
        env:
          PAT: ${{ secrets.PAT }}
        run: |
          git clone https://x-access-token:${PAT}@github.com/Jyf0214/veiled-journeys.git /mnt/ramdisk/veiled-journeys

      - name: Install Python requirements
        run: |
          pip install -r /mnt/ramdisk/veiled-journeys/requirements.txt

      - name: Download One Video File to RAM Disk
        run: |
          mkdir -p /mnt/ramdisk/video_work
          cd /mnt/ramdisk/veiled-journeys
          python webdav_download.py -a="MyVideos/" -b="../video_work/" -c=1
          cd /home/runner/work

      # 最核心的步骤：分段处理
      - name: Process Video in Segments to Avoid Timeout
        id: process
        run: |
          set -e # 如果任何命令失败，立即退出
          cd /mnt/ramdisk/video_work

          ORIGINAL_FILE_PATH=$(find . -maxdepth 1 -type f -name "*.mp4" -print -quit)
          if [ -z "$ORIGINAL_FILE_PATH" ]; then
            echo "::error::No .mp4 file found!"
            exit 1
          fi
          ORIGINAL_FILENAME=$(basename "$ORIGINAL_FILE_PATH")
          
          echo "Processing file: $ORIGINAL_FILENAME"

          # 1. 创建临时目录
          mkdir -p segments compressed_segments
          
          # 2. 分析：获取所有关键帧的时间戳，并格式化为逗号分隔的列表
          echo "Step 1: Analyzing keyframes..."
          KEYFRAME_TIMES=$(ffprobe -v error -select_streams v:0 -show_entries frame=key_frame,pkt_pts_time -of csv=p=0 "$ORIGINAL_FILENAME" | grep "1," | cut -d',' -f2 | tr '\n' ',' | sed 's/,$//')
          
          if [ -z "$KEYFRAME_TIMES" ]; then
            echo "::error::Could not find any keyframes in the video!"
            exit 1
          fi

          # 3. 无损分割：使用 segment muxer 快速分割视频
          echo "Step 2: Splitting video at keyframes (lossless)..."
          ffmpeg -i "$ORIGINAL_FILENAME" -f segment -segment_times "$KEYFRAME_TIMES" -reset_timestamps 1 -c copy "segments/segment_%03d.mp4"

          # 4. 并行压缩：循环压缩每一个片段
          echo "Step 3: Compressing segments in parallel..."
          CONCAT_LIST_FILE="concat_list.txt"
          > "$CONCAT_LIST_FILE"

          for f in segments/*.mp4; do
            BASENAME=$(basename "$f")
            COMPRESSED_SEGMENT_PATH="compressed_segments/$BASENAME"
            echo "Compressing $f -> $COMPRESSED_SEGMENT_PATH"
            # 使用 nohup 和 & 实现并行处理
            nohup ffmpeg -i "$f" -c:v libx265 -preset veryslow -crf 18 -tag:v hvc1 -c:a copy "$COMPRESSED_SEGMENT_PATH" > /dev/null 2>&1 &
            echo "file '$COMPRESSED_SEGMENT_PATH'" >> "$CONCAT_LIST_FILE"
          done

          # 等待所有后台的 ffmpeg 进程完成
          wait
          echo "All segments compressed."

          # 5. 无损合并：将压缩好的片段合并
          echo "Step 4: Merging compressed segments (lossless)..."
          MERGED_FILENAME="compressed_${ORIGINAL_FILENAME}"
          ffmpeg -f concat -safe 0 -i "$CONCAT_LIST_FILE" -c copy "$MERGED_FILENAME"

          # 6. 比较和清理
          echo "Step 5: Comparing sizes and cleaning up..."
          ORIGINAL_SIZE=$(stat -c%s "$ORIGINAL_FILENAME")
          COMPRESSED_SIZE=$(stat -c%s "$MERGED_FILENAME")
          
          echo "Original size: $ORIGINAL_SIZE bytes"
          echo "Compressed size: $COMPRESSED_SIZE bytes"
          
          FINAL_FILENAME="$ORIGINAL_FILENAME"
          
          if [ "$COMPRESSED_SIZE" -gt 0 ] && [ "$ORIGINAL_SIZE" -gt "$COMPRESSED_SIZE" ]; then
            echo "Compressed file is smaller. Keeping compressed version."
            # 用合并后的文件替换原始文件，以保持文件名一致
            mv "$MERGED_FILENAME" "final_output.mp4"
            rm "$ORIGINAL_FILENAME"
            mv "final_output.mp4" "$FINAL_FILENAME"
          else
            echo "Compressed file is not smaller or compression failed. Keeping original."
            rm "$MERGED_FILENAME"
          fi
          
          # 清理临时文件
          rm -rf segments compressed_segments "$CONCAT_LIST_FILE"

          echo "final_file=/mnt/ramdisk/video_work/$FINAL_FILENAME" >> $GITHUB_OUTPUT
          cd /home/runner/work

      - name: Upload to GoFile and Update List (Silent)
        run: |
          python /mnt/ramdisk/veiled-journeys/gofile_manager.py upload \
            --file "${{ steps.process.outputs.final_file }}" \
            --list-file "compressed_videos_list.txt" \
            > /dev/null 2>&1